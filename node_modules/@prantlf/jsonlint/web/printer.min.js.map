{
  "version": 3,
  "sources": ["../lib/printer.js"],
  "sourcesContent": ["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports)\n    : typeof define === 'function' && define.amd ? define('jsonlint-printer', ['exports'], factory)\n      : (global = global || self, factory(global.jsonlintPrinter = {}))\n}(this, function (exports) {\n  'use strict'\n\n  function noop () {}\n\n  function isIdentifierName (value) {\n    return /^[a-zA-Z$_][a-zA-Z0-9$_]*$/.test(value)\n  }\n\n  function concatenateTokens (tokens) {\n    let outputString = ''\n    const tokenCount = tokens.length\n    let tokenIndex\n    for (tokenIndex = 0; tokenIndex < tokenCount; ++tokenIndex) {\n      outputString += tokens[tokenIndex].raw\n    }\n    return outputString\n  }\n\n  function print (tokens, options) {\n    if (!(tokens?.length)) {\n      throw new Error('JSON tokens missing.')\n    }\n    // Whitespace and comments are available only as raw token content.\n    if (!(tokens[0]?.raw)) {\n      throw new Error('JSON tokens lack raw values.')\n    }\n\n    if (!options) {\n      // If no options, not even an empty object is passed, just concatenate\n      // the raw tokens with neither minification, nor pretty-printing.\n      return concatenateTokens(tokens)\n    }\n\n    let indentString = options.indent\n    if (typeof indentString === 'number') {\n      indentString = new Array(indentString + 1).join(' ')\n    }\n    // Setting the indent to an empty string enables pretty-printing too.\n    // It will just insert line breaks without any indentation.\n    const prettyPrint = indentString !== undefined\n    const pruneComments = options.pruneComments\n    const stripObjectKeys = options.stripObjectKeys\n    const enforceDoubleQuotes = options.enforceDoubleQuotes\n    const enforceSingleQuotes = options.enforceSingleQuotes\n    const trimTrailingCommas = options.trimTrailingCommas\n    const compactEmptyObjects = options.compactEmptyObjects !== false\n    const newLineChar = options.forceCrlf === true ? \"\\r\\n\" : \"\\n\"\n\n    let outputString = ''\n    let foundLineBreak\n    let addedLineBreak\n    let needsLineBreak\n    let addedSpace\n    let needsSpace\n    let indentLevel = 0\n    const scopes = []\n    let scopeType\n    let isValue\n    const tokenCount = tokens.length\n    let tokenIndex\n    let token\n    let tokenType\n    let tokenContent\n\n    function peekAtNextToken () {\n      let nextTokenIndex = tokenIndex\n      let nextToken\n      do {\n        nextToken = tokens[++nextTokenIndex]\n      } while (nextToken && (nextToken.type === 'whitespace' ||\n                             nextToken.type === 'comment'))\n      return nextToken\n    }\n\n    let addIndent\n    if (prettyPrint && indentString) {\n      addIndent = function () {\n        for (let i = 0; i < indentLevel; ++i) {\n          outputString += indentString\n        }\n      }\n    } else {\n      addIndent = noop\n    }\n\n    let addLineBreak\n    let addDelayedSpaceOrLineBreak\n    if (prettyPrint) {\n      addLineBreak = function () {\n        outputString += newLineChar\n      }\n\n      addDelayedSpaceOrLineBreak = function () {\n        // A line break is more important than a space.\n        if (needsLineBreak) {\n          addLineBreak()\n          addIndent()\n        } else if (needsSpace) {\n          outputString += ' '\n        }\n        needsSpace = needsLineBreak = false\n      }\n    } else {\n      addLineBreak = addDelayedSpaceOrLineBreak = noop\n    }\n\n    let addStandaloneComment\n    let tryAddingInlineComment\n    if (pruneComments) {\n      addStandaloneComment = tryAddingInlineComment = noop\n    } else {\n      if (prettyPrint) {\n        addStandaloneComment = function () {\n          // If a comment is not appended to the end of a line, it will start\n          // on a new line with the current indentation.\n          if (!addedLineBreak && tokenIndex > 0) {\n            addLineBreak()\n            addIndent()\n          }\n          outputString += tokenContent\n          foundLineBreak = false\n          addedLineBreak = false\n          // If a comment is not appended to the end of a line, it will take\n          // the whole line and has to end by a line break.\n          needsLineBreak = true\n        }\n\n        tryAddingInlineComment = function () {\n          // This function is called after printing a non-line-break character.\n          foundLineBreak = false\n          addedLineBreak = false\n          addedSpace = false\n\n          // Start with the character after the just processed one.\n          let tryTokenIndex = tokenIndex + 1\n\n          function skipWhitespace () {\n            let token = tokens[tryTokenIndex]\n            if (token && token.type === 'whitespace') {\n              foundLineBreak = token.raw.indexOf('\\n') >= 0\n              token = tokens[++tryTokenIndex]\n            }\n            return token\n          }\n\n          const token = skipWhitespace()\n          // If line break followed the previous token, leave the comment\n          // to be handled by the next usual token processing.\n          if (!foundLineBreak && token && token.type === 'comment') {\n            if (needsLineBreak) {\n              // If the previous non-whitespace token was ended by a line\n              // break, retain it. Print the comment after the line break too.\n              if (!addedLineBreak) {\n                addLineBreak()\n                addIndent()\n              }\n            } else {\n              // If the previous non-whitespace token was not ended by a line\n              // break, ensure that the comment is separated from it.\n              if (!addedSpace) {\n                outputString += ' '\n              }\n            }\n            outputString += token.raw\n            // Set the current token to the just processed comment.\n            tokenIndex = tryTokenIndex++\n            // Check the whitespace after the comment to give a hint\n            // about the next whitespace to the further processing.\n            skipWhitespace()\n            if (foundLineBreak) {\n              needsSpace = false\n              needsLineBreak = true\n            } else {\n              needsSpace = true\n              needsLineBreak = false\n            }\n          }\n        }\n      } else {\n        // If all whitespace is omitted, convert single-line comments\n        // to multi-line ones, which include a comment-closing token.\n        addStandaloneComment = function () {\n          if (tokenContent[1] === '/') {\n            outputString += '/*'\n            outputString += tokenContent.substr(2, tokenContent.length - 2)\n            outputString += ' */'\n          } else {\n            outputString += tokenContent\n          }\n        }\n\n        tryAddingInlineComment = noop\n      }\n    }\n\n    function addLiteral () {\n      addDelayedSpaceOrLineBreak()\n      const tokenValue = token.value\n      if (stripObjectKeys && scopeType === '{' && !isValue &&\n          isIdentifierName(tokenValue)) {\n        outputString += tokenValue\n      } else if (typeof tokenValue === 'string') {\n        if (enforceDoubleQuotes && tokenContent[0] !== '\"') {\n          outputString += JSON.stringify(tokenValue)\n        } else if (enforceSingleQuotes && tokenContent[0] !== '\\'') {\n          outputString += `'${tokenValue.replace(/'/g, '\\\\\\'')}'`\n        } else {\n          outputString += tokenContent\n        }\n      } else {\n        outputString += tokenContent\n      }\n      tryAddingInlineComment()\n    }\n\n    let justOpenedScope\n\n    function openScope () {\n      addDelayedSpaceOrLineBreak()\n      scopes.push(scopeType)\n      scopeType = tokenContent\n      isValue = scopeType === '['\n      outputString += tokenContent\n      tryAddingInlineComment()\n      ++indentLevel\n      needsLineBreak = justOpenedScope = true\n    }\n\n    function closeScope () {\n      scopeType = scopes.pop()\n      --indentLevel\n      if (!compactEmptyObjects || !justOpenedScope) {\n        addLineBreak()\n        addIndent()\n      }\n      needsSpace = needsLineBreak = justOpenedScope = false\n      outputString += tokenContent\n      tryAddingInlineComment()\n    }\n\n    function addComma () {\n      if (trimTrailingCommas) {\n        const nextToken = peekAtNextToken()\n        if (nextToken && nextToken.type === 'symbol') {\n          return tryAddingInlineComment()\n        }\n      }\n      addDelayedSpaceOrLineBreak()\n      outputString += ','\n      tryAddingInlineComment()\n      addLineBreak()\n      addIndent()\n      addedLineBreak = true\n      needsLineBreak = false\n      isValue = scopeType === '['\n    }\n\n    function addColon () {\n      addDelayedSpaceOrLineBreak()\n      outputString += ':'\n      needsSpace = true\n      tryAddingInlineComment()\n      isValue = true\n    }\n\n    for (tokenIndex = 0; tokenIndex < tokenCount; ++tokenIndex) {\n      token = tokens[tokenIndex]\n      tokenType = token.type\n      tokenContent = token.raw\n      switch (tokenType) {\n        case 'literal':\n          addLiteral()\n          break\n        case 'comment':\n          addStandaloneComment()\n          break\n        case 'symbol':\n          switch (tokenContent) {\n            case '{':\n            case '[':\n              openScope()\n              continue\n            case '}':\n            case ']':\n              closeScope()\n              continue\n            case ',':\n              addComma()\n              break\n            case ':':\n              addColon()\n          }\n          break\n        default: // whitespace\n          foundLineBreak = tokenContent.indexOf('\\n') >= 0\n          continue\n      }\n      justOpenedScope = false\n    }\n\n    return outputString\n  }\n\n  exports.print = print\n\n  Object.defineProperty(exports, '__esModule', { value: true })\n}))\n"],
  "mappings": "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",
  "names": ["global", "factory", "exports", "noop", "isIdentifierName", "value", "concatenateTokens", "tokens", "outputString", "tokenCount", "tokenIndex", "print", "options", "indentString", "prettyPrint", "pruneComments", "stripObjectKeys", "enforceDoubleQuotes", "enforceSingleQuotes", "trimTrailingCommas", "compactEmptyObjects", "newLineChar", "foundLineBreak", "addedLineBreak", "needsLineBreak", "addedSpace", "needsSpace", "indentLevel", "scopes", "scopeType", "isValue", "token", "tokenType", "tokenContent", "peekAtNextToken", "nextTokenIndex", "nextToken", "addIndent", "i", "addLineBreak", "addDelayedSpaceOrLineBreak", "addStandaloneComment", "tryAddingInlineComment", "tryTokenIndex", "skipWhitespace", "addLiteral", "tokenValue", "justOpenedScope", "openScope", "closeScope", "addComma", "addColon"]
}
